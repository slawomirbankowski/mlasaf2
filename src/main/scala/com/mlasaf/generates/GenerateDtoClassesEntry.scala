/*
  Author(s): Slawomir Bankowski
  Project: mlasaf
*/
package com.mlasaf.generates

/*
  Author(s): Slawomir Bankowski
  Project: mlasaf
*/
import anorm.SQL
import com.mlasaf.dto._
import com.mlasaf.structures.GenerateEntryOptions

/** generate all DTO classes */
object GenerateDtoClassesEntry {

  def main(args : Array[String]) = {
    val entryOptions = new GenerateEntryOptions(args);
    val jdbcString = entryOptions.jdbcString.getOrElse("")
    val jdbcUser = entryOptions.jdbcUser.getOrElse("")
    val jdbcPass = entryOptions.jdbcPass.getOrElse("")
    val jdbcDriver = entryOptions.jdbcDriver.getOrElse("")
    val baseFolder = entryOptions.baseFolder.getOrElse("")
    Class.forName(jdbcDriver);
    implicit val connmssql = java.sql.DriverManager.getConnection(jdbcString, jdbcUser, jdbcPass);
    val cols : List[ColumnDetailDto]=  SQL("select TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, case DATA_TYPE when 'bigint' then 'Long' when 'int' then 'Int' when 'nvarchar' then 'String' when 'varchar' then 'String' when 'datetime' then 'java.util.Date' when 'float' then 'Double'  else '' end as SCALA_TYPE from INFORMATION_SCHEMA.COLUMNS where  TABLE_NAME not like 'DATABASE%'")
      .as(anorm.Macro.namedParser[ColumnDetailDto].*);
    val pkCols : List[ColumnDetailDto] =  SQL(" select TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, '' as SCALA_TYPE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE where CONSTRAINT_NAME like 'PK%' and TABLE_NAME not like 'DATABASE%'")
      .as(anorm.Macro.namedParser[ColumnDetailDto].*);
    val fkCols : List[ColumnDetailDto] =  SQL(" select TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, '' as SCALA_TYPE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE where CONSTRAINT_NAME like 'FK%' and TABLE_NAME not like 'DATABASE%' ")
      .as(anorm.Macro.namedParser[ColumnDetailDto].*);
    cols.map(x => x.TABLE_NAME).distinct.sorted.foreach( tableName => {
      val dtoClassName = tableName.charAt(0).toUpper + tableName.substring(1) + "Dto";
      val generatedFileName = baseFolder + dtoClassName + ".scala";
      val outputContent : java.io.BufferedWriter = new java.io.BufferedWriter(new java.io.FileWriter(generatedFileName));
      outputContent.write("/*\n  Author(s): Slawomir Bankowski\n  Project: mlasaf\n  AUTOGENERATED CODE\n*/\npackage com.mlasaf.dto \n");
      outputContent.write(" \n");
      outputContent.write(" \n");
      val isTable = !tableName.startsWith("v");
      val baseDtoClassName = (if (isTable) "BaseDto" else "BaseReadOnlyDto")
      val allFieldsForDto = cols.filter(c => c.TABLE_NAME.equals(tableName));
      val fieldList = allFieldsForDto.map(col => col.COLUMN_NAME).mkString(",");
      val pkFieldList = pkCols.filter(c => c.TABLE_NAME.equals(tableName)).map(col => col.COLUMN_NAME).mkString(",");
      val primaryKeyFields = pkCols.filter(c => c.TABLE_NAME.equals(tableName)).map(col => col.COLUMN_NAME);
      val fkFieldList = fkCols.filter(c => c.TABLE_NAME.equals(tableName)).map(col => col.COLUMN_NAME).mkString(",");
      val nameCol = allFieldsForDto.filter(c => c.COLUMN_NAME.equals(c.TABLE_NAME + "Name")).map(c => c.COLUMN_NAME);
      val caseValueList = fieldList.split(",").map(f => "    case \"" + f + "\" => " + f + " ").mkString(" \n ");
      val insertColumns = allFieldsForDto.map(col => col.COLUMN_NAME).filter(c => !primaryKeyFields.contains(c) && !c.equals("insertedRowDate") && !c.equals("lastUpdatedDate"));
      val fieldQuestionList = insertColumns.map(col => "?").mkString(",");
      val caseTypeNameList = allFieldsForDto.map(f => "    case \"" + f.COLUMN_NAME + "\" => \"" + f.SCALA_TYPE + "\" ").mkString(" \n ");
      val prepareInsertStat = "    val stat = connection.prepareStatement(\"insert into " + tableName + "(" + insertColumns.mkString(",") + ") values (" + fieldQuestionList + ")\", java.sql.Statement.RETURN_GENERATED_KEYS);\n";
      var setSeq = 1;
      val pkNameNormalized = if (primaryKeyFields.size > 0) (primaryKeyFields.head) else (tableName.charAt(1).toLower + tableName.substring(2).replace("Summary", "") + "Id");
      val prepareInsertSet = insertColumns.zipWithIndex.map( f => "    stat.setObject(" + (f._2+1) + ", " + f._1 + ");").mkString("\n");
      val tableNameDef = " \n   def tableName : String = {    \"" + tableName + "\";    } ";
      val fieldsDef = " \n   def fields : String = {    \"" + fieldList + "\";    } ";
      val pkFields = " \n   def pkFields : String = {    \"" + pkFieldList + "\";    } ";
      val fkFields = " \n   def fkFields : String = {    \"" + fkFieldList + "\";    } ";
      var nameField = " \n   def nameField : String = {    \"" + nameCol.mkString(",") + "\";    } ";
      var getIdMethod = " ";
      var getPkMethod  = " \n def getPk() : Long = {    " + pkNameNormalized + "  } ";
      var getInsertedRowDateMethod  = " \n def getInsertedRowDate() : java.util.Date = {    insertedRowDate  } ";
      var getLastUpdatedDateMethod  = " \n def getLastUpdatedDate() : java.util.Date = {    lastUpdatedDate  } ";
      var getGuidMethod  = " \n def getGuid() : Long = {    guid  } ";
      var toAnyArray = " \n def toAnyArray() : Array[Any] = {    Array(" + fieldList + ")  } ";
      var toStringArray = " \n def toStringArray() : Array[String] = {    Array(" + fieldList.split(",").map(f => "\"\"+" + f).mkString(",") + ")   } ";

      var toJson = " \n def toJson() : String = {   \"{\" + " + fieldList.split(",").map(f => "\"\\\"" + f + "\\\":\\\"\"+" + f + "+\"\\\"\"").mkString("+\",\"+") + " + \"}\"   } ";
      var toFullString = " \n def toFullString() : String = {    " + fieldList.split(",").map(f => "\"" + f + ":'\"+" + f + "+\"'\"").mkString("+\",\"+") + "   } ";
      val getFieldValueMethodBody =  "\n   def getFieldValue(name : String) : Any = { \n    val ret = name match { \n" + caseValueList + "  \n    case _ => null \n    } \n    ret \n  } ";
      val getFieldNameeMethodBody =  "\n   def getFieldTypeName(name : String) : String = { \n    val ret = name match { \n" + caseTypeNameList + "  \n    case _ => \"Object\" \n    } \n    ret \n  } ";
      val prepareInsertMethod =(if (isTable) "\n   def prepareInsert(connection : java.sql.Connection) : java.sql.PreparedStatement = {\n " + prepareInsertStat + "" + prepareInsertSet + "\n    return stat; \n   } " else "");
      val createNewParams = allFieldsForDto
        .filter(c => !c.COLUMN_NAME.equals("guid") && !c.COLUMN_NAME.equals("insertedRowDate") && !c.COLUMN_NAME.equals("lastUpdatedDate") && !c.COLUMN_NAME.equals(pkFieldList))
        .map(c => "" + c.COLUMN_NAME + " : " + c.SCALA_TYPE).mkString(", ");
      val insertParamsList = allFieldsForDto.map(c => c.COLUMN_NAME match {
        case "guid" => "0"
        case "insertedRowDate" => "new java.util.Date()"
        case "lastUpdatedDate" => "new java.util.Date()"
        case _ => c.COLUMN_NAME
      } ).map(c => if (c.equals(pkFieldList)) "0" else c).mkString(",");
      val modifyParamsList = allFieldsForDto.map(c => c.COLUMN_NAME match {
        case "guid" => "this.guid"
        case "insertedRowDate" => "this.insertedRowDate"
        case "lastUpdatedDate" => "new java.util.Date()"
        case _ => c.COLUMN_NAME
      } ).map(c => if (c.equals(pkFieldList)) "this." + pkFieldList else c).mkString(",");
      val modifyHeaderDef = "\n   def modify(" + createNewParams + ") : " + dtoClassName + " = {";
      val modifyCreateNewDef = "    val dtoModified = new " + dtoClassName + "(" + modifyParamsList + ");";
      val modifyDef =  if (isTable) modifyHeaderDef + "\n" + modifyCreateNewDef +  "\n    dtoModified\n  }" else "";
      val allDefsList = tableNameDef + fieldsDef + pkFields + fkFields + nameField + getPkMethod + getInsertedRowDateMethod +getLastUpdatedDateMethod + getGuidMethod + toAnyArray + toStringArray + toJson + toFullString + getFieldValueMethodBody + getFieldNameeMethodBody + prepareInsertMethod + modifyDef + "\n";
      val fieldsCaseClassDefinitions = cols.filter(c => c.TABLE_NAME.equals(tableName)).map(col => "val " + col.COLUMN_NAME + " : " + col.SCALA_TYPE).mkString("\n     , ");
      val caseClassDef = "case class " + dtoClassName + " ( \n     " + fieldsCaseClassDefinitions + " \n     ) extends " + baseDtoClassName + " { " + allDefsList + " } ";
      val objectFieldsDef =allFieldsForDto.map(c => "   val FIELD_" + c.COLUMN_NAME + " = \"" + c.COLUMN_NAME + "\";").mkString("\n");

      val objectCreateNewDef = if (isTable) "\n  def createNew" + dtoClassName + "(" + createNewParams + ") : " + dtoClassName + " = {  \n     val dto = new " + dtoClassName + "(" + insertParamsList + ")   \n    dto \n  } \n" else "";
      val objectClassDef = "\nobject "+ dtoClassName + " { \n  val TABLE_NAME = \"" + tableName + "\"; \n" + objectFieldsDef + "\n" + objectCreateNewDef + "\n}\n\n";
      val totalDtoDef = caseClassDef + objectClassDef;
      outputContent.write(totalDtoDef);
      outputContent.write(" \n");
      outputContent.close();
    });

    connmssql.close();
  }

}

