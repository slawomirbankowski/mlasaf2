/*
  Author(s): Slawomir Bankowski
  Project: mlasaf
*/
package com.mlasaf.generates

import anorm.SQL
import com.mlasaf.dto.ColumnDetailDto
import com.mlasaf.structures.GenerateEntryOptions


object GenerateDtoMetadataEntry {

  def main(args : Array[String]) = {
    val entryOptions = new GenerateEntryOptions(args);
    val jdbcString = entryOptions.jdbcString.getOrElse("")
    val jdbcUser = entryOptions.jdbcUser.getOrElse("")
    val jdbcPass = entryOptions.jdbcPass.getOrElse("")
    val jdbcDriver = entryOptions.jdbcDriver.getOrElse("")
    val baseFolder = entryOptions.baseFolder.getOrElse("")

    val generatedFileName = baseFolder + "DtoMetadata.scala";
    val generatedFileNameJson = baseFolder + "columns.json";
    val outputContent : java.io.BufferedWriter = new java.io.BufferedWriter(new java.io.FileWriter(generatedFileName));
    outputContent.write("/*\n  Author(s): Slawomir Bankowski\n  Project: mlasaf\n  AUTOGENERATED CODE\n*/\npackage com.mlasaf.dto \n");
    outputContent.write(" \n");
    outputContent.write(" \n");
    Class.forName(jdbcDriver);
    implicit val connmssql = java.sql.DriverManager.getConnection(jdbcString, jdbcUser, jdbcPass);
    val cols : List[ColumnDetailDto]=  SQL("select TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, case DATA_TYPE when 'bigint' then 'Long' when 'int' then 'Int' when 'nvarchar' then 'String' when 'varchar' then 'String' when 'datetime' then 'java.util.Date' when 'float' then 'Double'  else '' end as SCALA_TYPE from INFORMATION_SCHEMA.COLUMNS where  TABLE_NAME not like 'DATABASE%'")
      .as(anorm.Macro.namedParser[ColumnDetailDto].*);
    val pkCols : List[ColumnDetailDto] =  SQL(" select TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, '' as SCALA_TYPE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE where CONSTRAINT_NAME like 'PK%' and TABLE_NAME not like 'DATABASE%'")
      .as(anorm.Macro.namedParser[ColumnDetailDto].*);
    val fkCols : List[ColumnDetailDto] =  SQL(" select TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, '' as SCALA_TYPE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE where CONSTRAINT_NAME like 'FK%' and TABLE_NAME not like 'DATABASE%' ")
      .as(anorm.Macro.namedParser[ColumnDetailDto].*);
    val dtosClassDef = new StringBuilder();

    dtosClassDef.append("\nobject DtoMetadata { \n");
    dtosClassDef.append("  def getDtoClasses() : Array[String] = {  columns.map(c => c.TABLE_NAME).distinct.map(t => t + \"Dto\"); } \n");
    dtosClassDef.append("  def getTableNames() : Array[String] = {  columns.map(c => c.TABLE_NAME).distinct; } \n");
    dtosClassDef.append("  def getPkNameForTable(tableName : String) : String = { tableName + \"Id\"; } \n");
    dtosClassDef.append("  def getColumns() : Array[ColumnDetailDto] = { columns; } \n");
    dtosClassDef.append("  def getColumnsForTable(tableName : String) : Array[ColumnDetailDto] = { columns.filter(c => c.TABLE_NAME.equals(tableName)); } \n");
    dtosClassDef.append("  val columns = Array( \n");
    dtosClassDef.append(cols.map(c => " ColumnDetailDto(\"" + c.TABLE_NAME + "\", \"" + c.COLUMN_NAME + "\", " + c.ORDINAL_POSITION + ", \"" + c.SCALA_TYPE + "\") \n").mkString("      , "))
    dtosClassDef.append("  ) \n");
    dtosClassDef.append("} \n");
    outputContent.write(dtosClassDef.toString());
    outputContent.write(" \n");
    outputContent.close();

    val outputContentJson : java.io.BufferedWriter = new java.io.BufferedWriter(new java.io.FileWriter(generatedFileNameJson));
    val dtosClassJson = new StringBuilder();
    dtosClassJson.append("[");
    dtosClassJson.append(cols.map(c => " { \"TABLE_NAME\":\"" + c.TABLE_NAME + "\", \"COLUMN_NAME\":\"" + c.COLUMN_NAME + "\", \"ORDINAL_POSITION\":" + c.ORDINAL_POSITION + ", \"SCALA_TYPE\":\"" + c.SCALA_TYPE + "\" } \n").mkString("      , "))
    dtosClassJson.append("]");
    outputContentJson.write(dtosClassJson.toString());
    outputContentJson.write(" \n");
    outputContentJson.close();
    connmssql.close();
  }

}
