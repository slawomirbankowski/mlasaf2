/*
  Author(s): Slawomir Bankowski
  Project: mlasaf
  AUTOGENERATED CODE
*/
package com.mlasaf.dao

import anorm.{SQL, SqlParser}
import com.mlasaf.dto._
import java.util.Date


 class ExecutorInstanceDao extends DaoBase { 

  def getExecutorInstancesList() : List[ExecutorInstanceDto] = {
   implicit val connection = getConnection();
   val dtos : List[ExecutorInstanceDto]= SQL("select * from executorInstance").as(anorm.Macro.namedParser[ExecutorInstanceDto].*);
   releaseConnection(connection);
   dtos
  }
  def getExecutorInstancesCount() : Long = {
   implicit val connection = getConnection();
   val cnt : Long = SQL("select count(*) as cnt from executorInstance").executeQuery()(connection).as[Long](SqlParser.long("cnt").single)(connection);
   releaseConnection(connection);
   cnt
  }
  def getExecutorInstancesLastInsertDate() : java.util.Date = {
   implicit val connection = getConnection();
   val ld : java.util.Date = SQL("select max(insertedRowDate) as lastDate from executorInstance").executeQuery()(connection).as[java.util.Date](SqlParser.date("lastDate").single)(connection);
   releaseConnection(connection);
   ld
  }
  def getExecutorInstancesLastUpdatedDate() : java.util.Date = {
   implicit val connection = getConnection();
   val ld : java.util.Date = SQL("select max(lastUpdatedDate) as lastUpdatedDate from executorInstance").executeQuery()(connection).as[java.util.Date](SqlParser.date("lastUpdatedDate").single)(connection);
   releaseConnection(connection);
   ld
  }
  def getExecutorInstanceFirst() : ExecutorInstanceDto = {
   implicit val connection = getConnection();
   val dtos : ExecutorInstanceDto= SQL("select * from executorInstance order by insertedRowDate asc ").as(anorm.Macro.namedParser[ExecutorInstanceDto].*).head;
   releaseConnection(connection);
   dtos
  }
  def getExecutorInstanceLast() : ExecutorInstanceDto = {
   implicit val connection = getConnection();
   val dtos : ExecutorInstanceDto= SQL("select * from executorInstance order by insertedRowDate desc ").as(anorm.Macro.namedParser[ExecutorInstanceDto].*).head;
   releaseConnection(connection);
   dtos
  }
  def getExecutorInstancesByField(fieldName : String, fieldValue : String) : List[ExecutorInstanceDto] = {
   implicit val connection = getConnection();
   val dtos : List[ExecutorInstanceDto]= SQL("select * from executorInstance where " + fieldName + " = {fieldValue} ").on("fieldValue" -> fieldValue).as(anorm.Macro.namedParser[ExecutorInstanceDto].*);
   releaseConnection(connection);
   dtos
  }
  def getExecutorInstanceByGuid(guid : Long) : ExecutorInstanceDto = {
   implicit val connection = getConnection();
   val dtos : ExecutorInstanceDto= SQL("select * from executorInstance where guid = {guid} ").on("guid" -> guid).as(anorm.Macro.namedParser[ExecutorInstanceDto].single);
   releaseConnection(connection);
   dtos
  }  
 def getExecutorInstanceByPk(pkColValue : Long) : ExecutorInstanceDto = { 
   implicit val connection = getConnection();  
   val dto : ExecutorInstanceDto = SQL("select * from executorInstance where executorInstanceId = {pkColValue} ").on("pkColValue" -> pkColValue).as(anorm.Macro.namedParser[ExecutorInstanceDto].single);  
   releaseConnection(connection);  
   dto  
 }  
 def getExecutorInstanceMaxId() : Long = { 
   implicit val connection = getConnection();  
   val maxid : Long = SQL("select max(executorInstanceId) as maxId from executorInstance ").executeQuery()(connection).as[Long](SqlParser.long("maxId").single)(connection);;  
   releaseConnection(connection);  
   maxid  
 }  
 def getExecutorInstanceByFkExecutorContextId(fkColValue : Long) : List[ExecutorInstanceDto] = { 
   implicit val connection = getConnection();  
   val dtos : List[ExecutorInstanceDto] = SQL("select * from executorInstance where executorContextId = {fkColValue} ").on("fkColValue" -> fkColValue).as(anorm.Macro.namedParser[ExecutorInstanceDto].*);  
   releaseConnection(connection);  
   dtos  
 }  
 def getExecutorInstanceByFkExecutorHostId(fkColValue : Long) : List[ExecutorInstanceDto] = { 
   implicit val connection = getConnection();  
   val dtos : List[ExecutorInstanceDto] = SQL("select * from executorInstance where executorHostId = {fkColValue} ").on("fkColValue" -> fkColValue).as(anorm.Macro.namedParser[ExecutorInstanceDto].*);  
   releaseConnection(connection);  
   dtos  
 }  
 def getExecutorInstanceByFkExecutorTypeId(fkColValue : Long) : List[ExecutorInstanceDto] = { 
   implicit val connection = getConnection();  
   val dtos : List[ExecutorInstanceDto] = SQL("select * from executorInstance where executorTypeId = {fkColValue} ").on("fkColValue" -> fkColValue).as(anorm.Macro.namedParser[ExecutorInstanceDto].*);  
   releaseConnection(connection);  
   dtos  
 }  
 def getExecutorInstanceByName(nameColValue : String) : List[ExecutorInstanceDto] = { 
   implicit val connection = getConnection();  
   val dtos : List[ExecutorInstanceDto] = SQL("select * from executorInstance where executorInstanceName = {nameColValue} ").on("nameColValue" -> nameColValue).as(anorm.Macro.namedParser[ExecutorInstanceDto].*);  
   releaseConnection(connection);  
   dtos  
 }  
 def getExecutorInstanceFirstByName(nameColValue : String) : Option[ExecutorInstanceDto] = { 
   implicit val connection = getConnection();  
   val dtos : List[ExecutorInstanceDto] = SQL("select * from executorInstance where executorInstanceName = {nameColValue} ").on("nameColValue" -> nameColValue).as(anorm.Macro.namedParser[ExecutorInstanceDto].*);  
   releaseConnection(connection);  
   if (dtos.size > 0) Some(dtos.head) else None  
 }  
 def insertExecutorInstanceDto(dto : ExecutorInstanceDto): ExecutorInstanceDto = { 
    implicit val connection = getConnection(); 
    val stat = dto.prepareInsert(connection); 
    val resCnt = stat.executeUpdate(); 
    val rs = stat.getGeneratedKeys(); 
    if (rs.next()) { 
      val pkValue = rs.getLong(1); 
      val r = SQL("select * from executorInstance where executorInstanceId = {pkValue} ").on("pkValue" -> pkValue).as(anorm.Macro.namedParser[ExecutorInstanceDto].single); 
      releaseConnection(connection);  
      r 
    } else { 
      releaseConnection(connection);  
      null; 
    } 
 } 
  def createAndInsertExecutorInstanceDto(executorTypeId : Long, executorHostId : Long, executorContextId : Long, executorInstanceName : String, executorDefinition : String, executorParameters : String, isRunning : Int, isFinished : Int, portNumber : Int, endDate : java.util.Date) : ExecutorInstanceDto = {
    val dto = new ExecutorInstanceDto(0,0,new Date(),new Date(),executorTypeId,executorHostId,executorContextId,executorInstanceName,executorDefinition,executorParameters,isRunning,isFinished,portNumber,endDate)
    insertExecutorInstanceDto(dto);   
  }   
  def updateExecutorInstanceDto(dto : ExecutorInstanceDto): ExecutorInstanceDto = {  
    implicit val connection = getConnection();  
      val resCnt = SQL("update executorInstance set  lastUpdatedDate = {lastUpdatedDate} ,  executorTypeId = {executorTypeId} ,  executorHostId = {executorHostId} ,  executorContextId = {executorContextId} ,  executorInstanceName = {executorInstanceName} ,  executorDefinition = {executorDefinition} ,  executorParameters = {executorParameters} ,  isRunning = {isRunning} ,  isFinished = {isFinished} ,  portNumber = {portNumber} ,  endDate = {endDate}  where  executorInstanceId = {executorInstanceId}  ")
      .on("lastUpdatedDate" -> dto.lastUpdatedDate , "executorTypeId" -> dto.executorTypeId , "executorHostId" -> dto.executorHostId , "executorContextId" -> dto.executorContextId , "executorInstanceName" -> dto.executorInstanceName , "executorDefinition" -> dto.executorDefinition , "executorParameters" -> dto.executorParameters , "isRunning" -> dto.isRunning , "isFinished" -> dto.isFinished , "portNumber" -> dto.portNumber , "endDate" -> dto.endDate, "executorInstanceId" -> dto.executorInstanceId ).executeInsert() 
   releaseConnection(connection);  
     getExecutorInstanceByPk(dto.executorInstanceId) 
    } 

} 
